import PDFDocument from "pdfkit";
import { storage } from "../storage";
import type { Gift, Agent } from "@shared/schema";
import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

interface GiftGenerationRequest {
  workspaceId: string;
  agentId?: string;
  conversationId?: string;
  createdById: string;
  title: string;
  description?: string;
  type: "pdf" | "slides" | "document" | "code" | "data";
  prompt: string;
  sourceData?: string;
  tags?: string[];
}

export async function generateGiftContent(prompt: string, type: string, sourceData?: string): Promise<string> {
  const systemPrompt = getSystemPromptForType(type);
  const userPrompt = sourceData 
    ? `Based on the following data:\n\n${sourceData}\n\n${prompt}`
    : prompt;

  const response = await openai.chat.completions.create({
    model: "gpt-4o",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt }
    ],
    temperature: 0.7,
  });

  return response.choices[0]?.message?.content || "";
}

function getSystemPromptForType(type: string): string {
  switch (type) {
    case "pdf":
      return `You are a professional document writer. Create well-structured content suitable for a PDF document.
Use clear headings with "# " prefix, bullet points with "- " prefix, and numbered lists with "1. " prefix.
Be thorough but concise. Format the content so it reads well as a formal document.`;
    
    case "slides":
      return `You are a presentation designer. Create content for slides.
Format each slide as:
---SLIDE---
# Title
- Bullet point 1
- Bullet point 2
Key takeaway or insight
---END SLIDE---

Keep each slide focused on one main point. Use clear, impactful language.`;
    
    case "document":
      return `You are a research analyst. Create comprehensive documentation.
Use proper structure with sections, subsections, and clear organization.
Include executive summaries, key findings, and recommendations where appropriate.`;
    
    case "code":
      return `You are a senior software engineer. Generate clean, well-commented code.
Include proper error handling, documentation, and best practices.
Format code blocks with proper syntax and explain the implementation.`;
    
    case "data":
      return `You are a data analyst. Transform and analyze the provided data.
Present findings in a clear, structured format with insights and recommendations.
Include relevant statistics and visualizations descriptions where helpful.`;
    
    default:
      return "You are a helpful assistant. Generate well-structured content based on the user's request.";
  }
}

export async function generatePDF(content: string, title: string): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ 
      margin: 50,
      size: 'A4',
      info: {
        Title: title,
        Author: 'Creative Intelligence',
        Subject: 'Agent-Generated Gift',
        Creator: 'CB | CREATIVES'
      }
    });
    
    const chunks: Buffer[] = [];
    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    doc.font('Helvetica-Bold').fontSize(24).fillColor('#E5A824')
       .text(title, { align: 'center' });
    doc.moveDown();
    
    doc.font('Helvetica').fontSize(10).fillColor('#666666')
       .text(`Generated by Creative Intelligence • ${new Date().toLocaleDateString()}`, { align: 'center' });
    doc.moveDown(2);

    const lines = content.split('\n');
    for (const line of lines) {
      if (line.startsWith('# ')) {
        doc.moveDown();
        doc.font('Helvetica-Bold').fontSize(18).fillColor('#333333')
           .text(line.substring(2));
        doc.moveDown(0.5);
      } else if (line.startsWith('## ')) {
        doc.moveDown(0.5);
        doc.font('Helvetica-Bold').fontSize(14).fillColor('#444444')
           .text(line.substring(3));
        doc.moveDown(0.3);
      } else if (line.startsWith('- ')) {
        doc.font('Helvetica').fontSize(11).fillColor('#333333')
           .text(`• ${line.substring(2)}`, { indent: 20 });
      } else if (/^\d+\.\s/.test(line)) {
        doc.font('Helvetica').fontSize(11).fillColor('#333333')
           .text(line, { indent: 20 });
      } else if (line.trim()) {
        doc.font('Helvetica').fontSize(11).fillColor('#333333')
           .text(line);
        doc.moveDown(0.3);
      } else {
        doc.moveDown(0.5);
      }
    }

    doc.moveDown(2);
    doc.font('Helvetica').fontSize(9).fillColor('#999999')
       .text('— CB | CREATIVES Creative Intelligence Platform —', { align: 'center' });

    doc.end();
  });
}

export async function generateSlides(content: string, title: string): Promise<string> {
  const slides = content.split('---SLIDE---').filter(s => s.trim());
  const slideData = slides.map((slide, index) => {
    const lines = slide.replace('---END SLIDE---', '').trim().split('\n').filter(l => l.trim());
    const slideTitle = lines[0]?.replace('# ', '') || `Slide ${index + 1}`;
    const bullets = lines.slice(1).filter(l => l.startsWith('- ')).map(l => l.substring(2));
    const notes = lines.slice(1).filter(l => !l.startsWith('- ')).join(' ');
    
    return {
      slideNumber: index + 1,
      title: slideTitle,
      bullets,
      notes: notes.trim()
    };
  });

  return JSON.stringify({
    presentationTitle: title,
    generatedAt: new Date().toISOString(),
    slides: slideData
  }, null, 2);
}

export async function createGift(request: GiftGenerationRequest): Promise<Gift> {
  const gift = await storage.createGift({
    workspaceId: request.workspaceId,
    agentId: request.agentId,
    conversationId: request.conversationId,
    createdById: request.createdById,
    title: request.title,
    description: request.description,
    type: request.type,
    status: "generating",
    sourceData: request.sourceData,
    tags: request.tags,
  });

  try {
    const content = await generateGiftContent(request.prompt, request.type, request.sourceData);
    
    let fileContent: string | Buffer;
    let mimeType: string;
    let fileName: string;

    if (request.type === "pdf") {
      fileContent = await generatePDF(content, request.title);
      mimeType = "application/pdf";
      fileName = `${request.title.toLowerCase().replace(/\s+/g, '-')}.pdf`;
    } else if (request.type === "slides") {
      fileContent = await generateSlides(content, request.title);
      mimeType = "application/json";
      fileName = `${request.title.toLowerCase().replace(/\s+/g, '-')}-slides.json`;
    } else {
      fileContent = content;
      mimeType = "text/plain";
      fileName = `${request.title.toLowerCase().replace(/\s+/g, '-')}.txt`;
    }

    const updatedGift = await storage.updateGift(gift.id, {
      status: "ready",
      content: typeof fileContent === 'string' ? fileContent : fileContent.toString('base64'),
      mimeType,
      fileName,
    });

    return updatedGift || gift;
  } catch (error) {
    console.error("Gift generation failed:", error);
    await storage.updateGift(gift.id, {
      status: "failed",
      content: error instanceof Error ? error.message : "Unknown error",
    });
    throw error;
  }
}

export async function getGiftContent(giftId: string): Promise<{ buffer: Buffer; mimeType: string; fileName: string } | null> {
  const gift = await storage.getGift(giftId);
  if (!gift || gift.status !== "ready" || !gift.content) {
    return null;
  }

  const buffer = gift.mimeType === "application/pdf" 
    ? Buffer.from(gift.content, 'base64')
    : Buffer.from(gift.content, 'utf-8');

  return {
    buffer,
    mimeType: gift.mimeType || "text/plain",
    fileName: gift.fileName || "gift.txt"
  };
}
